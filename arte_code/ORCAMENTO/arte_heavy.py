import pandas as pd
import google.generativeai as genai
import google.api_core.exceptions as google_exceptions
import os
from dotenv import load_dotenv
import json
import time
from openpyxl.styles import PatternFill

# ======================================================================
# CONFIGURA√á√ïES E CONSTANTES
# ======================================================================

# --- File Paths ---
BASE_DIR = r"C:\Users\pietr\OneDrive\.vscode\arte_"
CAMINHO_EDITAL = r"C:\Users\pietr\OneDrive\.vscode\arte_\DOWNLOADS\master.xlsx"
CAMINHO_SAIDA = r"C:\Users\pietr\OneDrive\.vscode\arte_\DOWNLOADS\master_heavy.xlsx"
CAMINHO_BASE = r"DOWNLOADS/RESULTADO_metadados/categoria_claude_sonnet_v5.xlsx"

# --- Financial Parameters ---
PROFIT_MARGIN = 0.53  # MARGEM DE LUCRO 
INITIAL_PRICE_FILTER_PERCENTAGE = 0.60  # FILTRO DE PRE√áO DOS PRODUTOS NA BASE

# --- AI Model Configuration ---
# Lista de modelos para fallback. O script tentar√° o primeiro e, em caso de
# erro de cota, passar√° para o pr√≥ximo da lista.
LLM_MODELS_FALLBACK = [
    "gemini-2.0-flash-lite",
    "gemini-2.5-flash",
    "gemini-2.5-flash-lite",
    "gemini-2.0-flash",
    "gemini-2.5-pro",
    "gemini-1.5-flash", 
]

# --- Subcategorization Keywords ------------------------------------
# A IA agora usar√° esta lista para identificar a subcategoria diretamente.
ALL_SUBCATEGORIES = [
    'arco', 'cavalete', 'corda', 'kit nut', 'kit rastilho', 'bag', 'banco', 
    'carrinho prancha', 'estante de partitura', 'suporte', 'baqueta', 
    'carrilh√£o', 'esteira', 'M√°quina de Hi Hat', 'Pad para Bumbo', 'parafuso', 
    'pedal de bumbo', 'pele', 'prato', 'sino', 'talabarte', 'tri√¢ngulo', 
    'graxa', 'oleo lubrificante', 'palheta de saxofone/clarinete', 
    'fone de ouvido', 'globo microfone', 'Interface de guitarra', 'pedal', 
    'mesa de som', 'microfone', 'cabo CFTV', 'cabo de rede', 'caixa medusa', 
    'Medusa', 'P10', 'P2xP10', 'painel de conex√£o', 'xlr M/F', 'amplificador', 
    'caixa de som', 'cubo para guitarra', "violino", "viola", "viol√£o", 
    "guitarra", "baixo", "violoncelo", "afuch√©", "bateria", "bombo", "bumbo", 
    "caixa de guerra", "caixa tenor", "ganza", "pandeiro", "quadriton", 
    "reco reco", "surdo", "tambor", "tarol", "timbales", "trompete", 
    "bombardino", "trompa", "trombone", "tuba", "sousafone", "clarinete", 
    "saxofone", "flauta", "tuba bombard√£o", "flugelhorn", "euphonium", 
    "piano", "teclado digital", "glockenspiel", "metalofone"
]

# ============================================================ 
# FUN√á√ïES DE SUPORTE
# ============================================================ 

def gerar_conteudo_com_fallback(prompt: str, modelos: list[str]) -> str | None:
    """
    Tenta gerar conte√∫do usando uma lista de modelos em ordem de prefer√™ncia.
    Se um modelo falhar por cota (ResourceExhausted), tenta o pr√≥ximo.
    """
    for nome_modelo in modelos:
        try:
            print(f"   - Tentando chamada √† API com o modelo: {nome_modelo}...")
            model = genai.GenerativeModel(nome_modelo)
            response = model.generate_content(prompt)

            if not response.parts:
                finish_reason = response.candidates[0].finish_reason.name if response.candidates else 'N/A'
                print(f"   - ‚ùå A GERA√á√ÉO RETORNOU VAZIA. Motivo: {finish_reason}. Isso pode ser causado por filtros de seguran√ßa.")
                return None

            print(f"   - Sucesso com o modelo '{nome_modelo}'.")
            return response.text
        except google_exceptions.ResourceExhausted as e:
            print(f"- ‚ö†Ô∏è Cota excedida para o modelo '{nome_modelo}'. Tentando o pr√≥ximo da lista.")
            time.sleep(5)
            continue
        except Exception as e:
            print(f"   - ‚ùå Erro inesperado com o modelo '{nome_modelo}': {e}")
            return None
    print("   - ‚ùå FALHA TOTAL: Todos os modelos na lista de fallback falharam.")
    return None

def get_subcategory_from_ai(description: str, subcategories: list) -> str:
    """Usa o modelo de IA para extrair a subcategoria mais apropriada da descri√ß√£o do item."""
    print("-üó£Ô∏è Asking AI for the item subcategory...")
    
    prompt = f"""
    <objetivo>
    Voc√™ √© um especialista em instrumentos musicais e equipamentos de √°udio.
    Sua tarefa √© analisar a descri√ß√£o do item a seguir e identificar a qual subcategoria de produto ele pertence.
    Responda APENAS com o nome da subcategoria da lista fornecida que melhor descreve o item.
    Se o item parecer uma combina√ß√£o ou n√£o se encaixar perfeitamente, escolha a subcategoria do componente principal. 
    </objetivo>

    <item_descricao>
    {description}
    </item_descricao>

    <lista_de_subcategorias_validas>
    {json.dumps(subcategories, indent=2)}
    </lista_de_subcategorias_validas>

    Subcategoria:
    """
    
    response_text = gerar_conteudo_com_fallback(prompt, LLM_MODELS_FALLBACK)
    if response_text:
        # Limpa a resposta para garantir que seja apenas a subcategoria
        subcategory = response_text.strip().replace("'", "").replace('"', '').lower()
        
        # Valida√ß√£o para garantir que a IA retornou uma subcategoria v√°lida da lista
        if subcategory in [s.lower() for s in subcategories]:
            # Retorna a subcategoria com a capitaliza√ß√£o original da lista
            original_case_subcategory = next(s for s in subcategories if s.lower() == subcategory)
            return original_case_subcategory
        else:
            print(f"   - WARNING: AI returned an invalid or new subcategory: '{subcategory}'. Defaulting to OUTROS.")
            return "OUTROS"
    else:
        print(f"   - ERROR: AI call for subcategorization failed for all models.")
        return "OUTROS"


def get_best_match_from_ai(item_edital, df_candidates):
    """Usa o modelo de IA para encontrar o melhor match dentro dos candidatos."""
    print("-üó£Ô∏èAsking AI for the best match...")

    candidates_json = df_candidates[['DESCRICAO','categoria_principal','subcategoria','MARCA','MODELO','VALOR']] \
                        .to_json(orient="records", force_ascii=False, indent=2)

    prompt = f"""<identidade>Voc√™ √© um consultor de licita√ß√µes com 20+ anos de experi√™ncia em √°udio/instrumentos, focado na Lei 14.133/21, economicidade e menor pre√ßo.</identidade>
<objetivo>
1. Analise tecnicamente o item do edital: "{item_edital['DESCRICAO']}"
2. Compare-o com cada produto na <base_fornecedores_filtrada>.
3. **Sele√ß√£o Prim√°ria**: Encontre o produto da base que seja >=95% compat√≠vel. Dentre os compat√≠veis, escolha o de **menor 'Valor'**.
4. **Sele√ß√£o Secund√°ria**: Se nenhum produto for >=95% compat√≠vel, identifique o produto tecnicamente mais pr√≥ximo e detalhe as especifica√ß√µes que n√£o foram atendidas.
5. Use o Google para pesquisar e confirmar as especifica√ß√µes t√©cnicas dos produtos candidatos para garantir uma an√°lise precisa.
6. Responda **apenas** com um objeto JSON seguindo o <formato_saida>.
</objetivo>

<formato_saida>
Responda APENAS com um √∫nico objeto JSON. N√£o inclua ```json, explica√ß√µes ou qualquer outro texto.

**CASO 1: Encontrou um produto >=95% compat√≠vel.**
{{
  "best_match": {{
    "Marca": "Marca do Produto",
    "Modelo": "Modelo do Produto",
    "Valor": 1234.56,
    "Descricao_fornecedor": "Descri√ß√£o completa do produto na base",
    "Compatibilidade_analise": "An√°lise quantitativa da compatibilidade. Ex: 'Compat√≠vel. Atende a 5 de 6 especifica√ß√µes chave.'"
  }}
}}

**CASO 2: NENHUM produto √© >=95% compat√≠vel.**
Retorne "best_match" como `null`. Adicionalmente, inclua "closest_match" com os dados do produto mais pr√≥ximo e "reasoning" explicando o motivo da incompatibilidade.
{{
  "best_match": null,
  "reasoning": "Explique o principal motivo da incompatibilidade. Ex: 'Nenhum produto atende √† especifica√ß√£o de material X ou pot√™ncia Y.'",
  "closest_match": {{
    "Marca": "Marca do Produto Mais Pr√≥ximo",
    "Modelo": "Modelo do Mais Pr√≥ximo",
    "Valor": 4321.98,
    "Descricao_fornecedor": "Descri√ß√£o do produto mais pr√≥ximo.",
    "Compatibilidade_analise": "An√°lise da compatibilidade parcial com detalhes. Ex: 'Atende [especifica√ß√£o A, B], mas falha em [especifica√ß√£o C (material), D (pot√™ncia)].'"
  }}
}}
</formato_saida>

<base_fornecedores_filtrada>
{candidates_json}
</base_fornecedores_filtrada>"""

    response_text = gerar_conteudo_com_fallback(prompt, LLM_MODELS_FALLBACK)
    if response_text:
        try:
            cleaned_response = response_text.strip().replace("```json","",).replace("```","")
            return json.loads(cleaned_response)
        except json.JSONDecodeError as e:
            print(f"   - ERROR decoding JSON from AI: {e}")
            return {"best_match": None, "closest_match": None, "reasoning": f"Erro na decodifica√ß√£o do JSON da API: {e}"}
    else:
        return {"best_match": None, "closest_match": None, "reasoning": "Falha na chamada da API para todos os modelos de fallback."}

# ============================================================ 
# MAIN
# ============================================================ 

def main():
    print("Starting the product matching process...")

    load_dotenv()
    api_key = os.getenv("GOOGLE_API_KEY")
    if not api_key:
        print("ERROR: GOOGLE_API_KEY not found in .env file.")
        return

    genai.configure(api_key=api_key)

    try:
        df_edital = pd.read_excel(CAMINHO_EDITAL)
        df_base = pd.read_excel(CAMINHO_BASE)
        print(f"üëæ Edital loaded: {len(df_edital)} items from {os.path.basename(CAMINHO_EDITAL)}")
        print(f"üìØ Product base loaded: {len(df_base)} products from {os.path.basename(CAMINHO_BASE)}")
    except FileNotFoundError as e:
        print(f"ERROR: Could not load data files. Details: {e}")
        return

    if os.path.exists(CAMINHO_SAIDA):
        print(f"   - Loading existing data from: {os.path.basename(CAMINHO_SAIDA)}")
        df_existing = pd.read_excel(CAMINHO_SAIDA)
        existing_keys = set(zip(df_existing['ARQUIVO'].astype(str), df_existing['N¬∫'].astype(str)))
    else:
        df_existing = pd.DataFrame()
        existing_keys = set()

    df_edital_new = df_edital[~df_edital.apply(lambda row: (str(row['ARQUIVO']), str(row['N¬∫'])) in existing_keys, axis=1)].copy()

    if df_edital_new.empty:
        print("\n‚úÖ No new items to process. The output file is already up to date.")
        return

    print(f"   - Found {len(df_edital_new)} new items to process.")
    results = []
    total_new_items = len(df_edital_new)

    for idx, item_edital in df_edital_new.iterrows():
        descricao = str(item_edital['DESCRICAO'])
        print(f"\n üìà Processing new item {df_edital_new.index.get_loc(idx) + 1}/{total_new_items}: {descricao[:60]}...")
        status = ""
        best_match_data = None
        closest_match_data = None
        reasoning = None
        data_to_populate = None

        valor_unit_edital = float(str(item_edital.get('VALOR_UNIT', '0')).replace(',', '.'))

        if valor_unit_edital > 0:
            max_cost = valor_unit_edital * INITIAL_PRICE_FILTER_PERCENTAGE
            df_candidates = df_base[df_base['VALOR'] <= max_cost].copy()
        else:
            print("- ‚ÑπÔ∏è Valor de refer√™ncia do edital √© R$0.00 ou inv√°lido. Analisando todos os produtos da base.")
            df_candidates = df_base.copy()

        if df_candidates.empty:
            if valor_unit_edital > 0:
                print(f"- ‚ö†Ô∏è Nenhum produto encontrado abaixo do custo m√°ximo de R${max_cost:.2f}.")
            status = "Nenhum Produto com Margem"
        else:
            # --- L√ìGICA DE FILTRAGEM ATUALIZADA ---
            # 1. Obter a subcategoria espec√≠fica via IA
            item_subcategory = get_subcategory_from_ai(descricao, ALL_SUBCATEGORIES)
            time.sleep(10)
            print(f"   - AI categorized item into subcategory: {item_subcategory}")

            # 2. Filtrar a base de dados pela subcategoria retornada
            df_final_candidates = df_candidates[df_candidates['subcategoria'].str.lower() == item_subcategory.lower()]

            if df_final_candidates.empty:
                print(f"- ‚ö†Ô∏è Nenhum produto encontrado na subcategoria '{item_subcategory}'.")
                status = "Nenhum Produto na Subcategoria"
            else:
                print(f"  ü¶Ü - Temos {len(df_final_candidates)} candidatos ap√≥s a filtragem por subcategoria.")
                ai_result = get_best_match_from_ai(item_edital, df_final_candidates)
                time.sleep(30)

                best_match_data = ai_result.get("best_match")
                closest_match_data = ai_result.get("closest_match")
                reasoning = ai_result.get("reasoning")

                if best_match_data:
                    print(f" ‚úÖ - AI recomenda: {best_match_data.get('Marca', 'N/A')} {best_match_data.get('Modelo', 'N/A')}")
                    status = "Match Encontrado"
                    data_to_populate = best_match_data
                elif closest_match_data:
                    print(f"- üíç AI sugere como mais pr√≥ximo: {closest_match_data.get('Marca', 'N/A')} {closest_match_data.get('Modelo', 'N/A')}")
                    if reasoning:
                        print(f"    Motivo: {reasoning}")
                    status = "Match Parcial (Sugest√£o)"
                    data_to_populate = closest_match_data
                else:
                    print(" ‚ùå - AI n√£o encontrou produto compat√≠vel ou pr√≥ximo.")
                    if reasoning:
                        print(f"    Motivo: {reasoning}")
                    status = "Nenhum Produto Compat√≠vel"


        result_row = {
            'ARQUIVO': item_edital['ARQUIVO'],
            'N¬∫': item_edital['N¬∫'],
            'DESCRICAO_EDITAL': item_edital['DESCRICAO'],
            'VALOR_UNIT_EDITAL': item_edital['VALOR_UNIT'],
            'STATUS': status,
            'QTDE': item_edital.get('QTDE', 0),
            'LOCAL_ENTREGA': item_edital.get('LOCAL_ENTREGA', ''),
            'INTERVALO_LANCES': item_edital.get('INTERVALO_LANCES', ''),
            'MOTIVO_INCOMPATIBILIDADE': reasoning if status != "Match Encontrado" else None
        }

        if data_to_populate:
            cost_price = float(data_to_populate.get('Valor') or 0)
            final_price = cost_price * (1 + PROFIT_MARGIN)
            margem_valor = final_price - cost_price
            qtde = int(item_edital.get('QTDE', 0) or 0)
            margem_total = margem_valor * qtde
            result_row.update({
                'MARCA_SUGERIDA': data_to_populate.get('Marca'),
                'MODELO_SUGERIDO': data_to_populate.get('Modelo'),
                'CUSTO_FORNECEDOR': cost_price,
                'PRECO_FINAL_VENDA': final_price,
                'MARGEM_LUCRO_VALOR': margem_valor,
                'MARGEM_LUCRO_TOTAL': margem_total,
                'DESCRICAO_FORNECEDOR': data_to_populate.get('Descricao_fornecedor'),
                'ANALISE_COMPATIBILIDADE': data_to_populate.get('Compatibilidade_analise')
            })

        results.append(result_row)

    print("\nProcess finished. Generating output file...")

    if not results:
        print("- ‚ö†Ô∏è No new results were generated to add.")
        return

    df_results = pd.DataFrame(results)
    
    df_final = pd.concat([df_existing, df_results], ignore_index=True)

    output_columns = [
        'ARQUIVO','N¬∫','STATUS','DESCRICAO_EDITAL','VALOR_UNIT_EDITAL',
        'MARCA_SUGERIDA','MODELO_SUGERIDO','QTDE','CUSTO_FORNECEDOR',
        'PRECO_FINAL_VENDA','MARGEM_LUCRO_VALOR','MARGEM_LUCRO_TOTAL',
        'MOTIVO_INCOMPATIBILIDADE','DESCRICAO_FORNECEDOR','ANALISE_COMPATIBILIDADE',
        'LOCAL_ENTREGA','INTERVALO_LANCES'
    ]
    
    for col in output_columns:
        if col not in df_final.columns:
            df_final[col] = ''
    df_final = df_final[output_columns]

    output_dir = os.path.dirname(CAMINHO_SAIDA)
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    try:
        writer = pd.ExcelWriter(CAMINHO_SAIDA, engine='openpyxl')
        df_final.to_excel(writer, index=False, sheet_name='Proposta')

        workbook = writer.book
        worksheet = writer.sheets['Proposta']

        green_fill = PatternFill(start_color='C6EFCE', end_color='C6EFCE', fill_type='solid')
        yellow_fill = PatternFill(start_color='FFEB9C', end_color='FFEB9C', fill_type='solid')
        red_fill = PatternFill(start_color='FFC7CE', end_color='FFC7CE', fill_type='solid')

        for row_idx, status in enumerate(df_final['STATUS'], 2):
            fill_to_apply = None
            if status == "Match Encontrado":
                fill_to_apply = green_fill
            elif status == "Match Parcial (Sugest√£o)":
                fill_to_apply = yellow_fill
            elif status in ["Nenhum Produto com Margem", "Nenhum Produto na Subcategoria", "Nenhum Produto Compat√≠vel"]:
                fill_to_apply = red_fill

            if fill_to_apply:
                for col_idx in range(1, len(df_final.columns) + 1):
                    worksheet.cell(row=row_idx, column=col_idx).fill = fill_to_apply
        
        writer.close()
        print(f"‚úÖ Success! Output file updated at: {CAMINHO_SAIDA}")
    except Exception as e:
        print(f"‚ùå Error writing output file: {e}")


if __name__ == "__main__":
    main()
